<?php

/**
 * Helper function to fake comments.
 */
function _ckeditor_comments() {
  return array(
    1234 => array(
      'uid' => 1,
      'comment' => 'Testing this comment',
      'timestamp' => 1381211248,
      'pid' => NULL,
      'resolved' => 0,
    ),
    1235 => array(
      'uid' => 2,
      'comment' => 'Reply to first comment',
      'timestamp' => 1381211258,
      'pid' => 1234,
      'resolved' => 0,
    ),
    1236 => array(
      'uid' => 4,
      'comment' => 'Testing another comment',
      'timestamp' => 1381211584,
      'pid' => NULL,
      'resolved' => 0,
    ),
    1237 => array(
      'uid' => 4,
      'comment' => 'Resolved comment',
      'timestamp' => 1381211627,
      'pid' => NULL,
      'resolved' => 0,
    ),
  );
}

/**
 * Implements hook_menu().
 */
function ckeditor_comments_menu() {
  $items['ajax/ckeditor/comment'] = array(
    'title' => 'AJAX CKEditor Comment Action',
    'page callback' => 'ckeditor_comments_ajax_callback',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * AJAX callback for processing CKEditor inline comment actions.
 */
function ckeditor_comments_ajax_callback() {
  $json = array();
  // @todo put in some XSS validation here.
  switch ($_POST['action']) {
    // @todo create a function to save a comment.
    case 'comment_save:':
      break;

    // @todo create a real function for loading a single comment.
    case 'comment_load':
      $comments = _ckeditor_comments();
      if (!empty($comments[$_POST['cid']])) {
        $comment = $comments[$_POST['cid']];
        $json['content'] = '<strong>' . format_username(user_load($comment['uid'])) . '</strong>';
        $json['content'] .= '<div class="comment">' . $comment['comment'] . '</div>';
      }
      break;

    // Loads comments for an entity.
    case 'field_load_comments':
      $json['content'] = ckeditor_comments_field_load_comments($_POST['type'], $_POST['bundle'], $_POST['id'], $_POST['vid'], $_POST['summary']);
      break;
  }
  drupal_json_output($json);
  drupal_exit();
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ckeditor_comments_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  $field = $form['#field'];
  $settings = $form['#instance']['settings'];
  if ($field['type'] === 'text_long' || $field['type'] === 'text_with_summary') {
    $form['instance']['settings']['ckeditor_comments'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable inline comments in CKEditor'),
      '#description' => t('This allows any CKEditor instance to use inline commenting for this field.'),
      '#default_value' => isset($settings['ckeditor_comments']) ? $settings['ckeditor_comments'] : FALSE,
    );
  }
}

/**
 * Implements hook_element_info_alter().
 */
function ckeditor_comments_element_info_alter(&$info) {
  $info['text_format']['#process'][] = '_ckeditor_comments_process_text_format';
}

/**
 * Process callback for text_format elements.
 */
function _ckeditor_comments_process_text_format(&$element, &$form_state) {
  // Only process text areas that have been flagged.
  if (!empty($element['#field_name'])
    && !empty($element['#language'])
    && !empty($form_state['field'][$element['#field_name']][$element['#language']]['instance']['settings']['ckeditor_comments'])
  ) {
    $attributes = array(
      'class' => array('cke-inline-comments'),
      'data-summary' => '0',
    );
    if (!empty($element['#entity_type']) && !empty($element['#entity'])) {
      list($id, $vid, $bundle) = entity_extract_ids($element['#entity_type'], $element['#entity']);
      $attributes['data-type'] = $element['#entity_type'];
      $attributes['data-id'] = $id;
      $attributes['data-vid'] = $vid;
      $attributes['data-bundle'] = $bundle;
    }
    $field = $form_state['field'][$element['#field_name']][$element['#language']]['field'];
    if (($field['type'] === 'text_long' || $field['type'] === 'text_with_summary') && !empty($element['value'])) {
      if (!isset($element['value']['#attributes'])) {
        $element['value']['#attributes'] = array();
      }
      $element['value']['#attributes'] = drupal_array_merge_deep($element['value']['#attributes'], $attributes);
      // Summaries.
      if ($field['type'] === 'text_with_summary' && !empty($element['summary'])) {
        if (!isset($element['summary']['#attributes'])) {
          $element['summary']['#attributes'] = array();
        }
        $attributes['data-summary'] = '1';
        $element['summary']['#attributes'] = drupal_array_merge_deep($element['summary']['#attributes'], $attributes);
      }
    }
  }
  return $element;
}

/**
 * Load a text_format field's inline comments for a specific entity.
 *
 * @param string $type
 *   Type of entity to load.
 * @param string $bundle
 *   Bundle name of entity to load.
 * @param int $id
 *   ID of entity to load.
 * @param int $vid
 *   Version ID of entity to load.
 * @param bool $summary
 *   Retrieve the field's summary value instead (if it exists).
 *
 * @return bool|string
 *   The value of the field (or summary) containing comments, FALSE if no
 *   comments exist for this field.
 */
function ckeditor_comments_field_load_comments($type, $bundle, $id, $vid = 0, $summary = FALSE) {
  // Simulates a DB query for returning the value of the text_format textarea
  // prior to the comments being stripped out.
  // @todo replace with real DB query once a proper schema has been setup.
  if ($type === 'node' && $bundle === 'page' && (int) $id === 4 && (int) $vid === 4 && (int) $summary === 0) {
    return '<p>Donec ullamcorper nulla non <span data-cid="1234">metus auctor</span> fringilla. <span data-cid="1236">Vestibulum</span> id ligula porta felis euismod semper. Cras mattis <span data-cid="1237">consectetur purus sit amet</span> fermentum. Cras justo odio, dapibus ac facilisis in, egestas eget quam. Donec sed odio dui. Nullam id dolor id nibh ultricies vehicula ut id elit. Donec sed odio dui.</p>';
  }
  return FALSE;
}

/**
 * Implements hook_ckeditor_plugin().
 *
 * Provides plugin to add support for inline commenting in CKEditor.
 */
function ckeditor_comments_ckeditor_plugin() {
  return array(
    'inline_comment' => array(
      'name' => 'inline_comment',
      'desc' => t('Support inline commenting in CKEditor.'),
      'path' => drupal_get_path('module', 'ckeditor_comments') . '/plugin/',
      'buttons' => array(
        'inline_comment' => array(
          'icon' => 'inline-comment.png',
          'label' => t('Comment'),
        ),
      ),
      'default' => 't',
    ),
  );
}

/**
 * Implements hook_ckeditor_settings_alter().
 */
function ckeditor_comments_ckeditor_settings_alter(&$settings) {
  static $init = FALSE;
  if (!$init) {
    $init = TRUE;
    $users = array();
    foreach (entity_load('user', array(1, 2, 3)) as $user) {
      $users[$user->uid] = array(
        'uid' => $user->uid,
        'name' => format_username($user),
        'picture' => theme('user_picture', array('account' => $user)),
        'color' => _ckeditor_comments_generate_color(),
      );
    }
    drupal_add_js(array(
      'CKEditor' => array(
        'inline_comments' => array(
          'edit-body-und-0-value' => array(
            'comments' => _ckeditor_comments(),
          ),
        ),
      ),
    ), 'setting');
  }
}

/**
 * Generate a unique random color.
 */
function _ckeditor_comments_generate_color() {
  static $colors = array();
  $color = sprintf("#%06x", rand(0, 16777215));
  // If color was already generated, generate a new one.
  if (in_array($color, $colors)) {
    return _ckeditor_comments_generate_color();
  }
  return $colors[] = $color;
}
